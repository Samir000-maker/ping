<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Multi-Server Keep-Alive Ping & Logger</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 18px; background: #fff; }
  h1 { margin-top: 0; font-size: 22px; }
  h2 { font-size: 17px; margin-bottom: 4px; }
  .note { color:#555; font-size:13px; margin-bottom:10px; }
  .server-box { border:1px solid #ccc; border-radius:8px; padding:12px; margin-bottom:16px; background:#fafafa; }
  #globalControls { margin-bottom: 20px; }
  button { padding:7px 12px; border-radius:6px; border:1px solid #ccc; background:#f6f6f6; cursor:pointer; }
  button.important { background:#0b84ff; color:#fff; border-color:#0b6fe0; }
  button:disabled { opacity:0.6; cursor:default; }
  .stats { margin-top:6px; font-size:13px; color:#333; }
  .logArea { white-space: pre-wrap; font-family: "Courier New", monospace; background:#0b0b0b; color:#e6e6e6;
    padding:10px; border-radius:6px; height:200px; overflow:auto; border:1px solid #ddd; margin-top:6px; }
  .line-ok { color: #8ef08e; }
  .line-warn { color: #ffd27a; }
  .line-err { color: #ff9a9a; }
</style>
</head>
<body>

<h1>Multi-Server Keep-Alive Ping & Logger</h1>
<div class="note">
  Pings every <strong>2 minutes</strong> (120s) with polite backoff for 429/503 errors.  
  Each server has its own pause/resume and log area.
</div>

<div id="serversContainer"></div>

<script>
(() => {
  // CONFIG
  const SERVERS = [
    { name: "Main Server", url: "https://samir-hgr9.onrender.com/health" },
    { name: "Server 1", url: "https://server1-ki1x.onrender.com/health" },
    { name: "Database Server", url: "https://database-22io.onrender.com/health" },
    { name: "Local Server", url: "https://local-server-yi1q.onrender.com/health" },
  ];

  const TARGET_INTERVAL_MS = 120000; // 2 minutes
  const JITTER_MS = 3000;
  const FETCH_TIMEOUT_MS = 8000;
  const MAX_BACKOFF_MS = 5 * 60 * 1000;
  const MAX_LOG_LINES = 400;

  const serversContainer = document.getElementById("serversContainer");

  SERVERS.forEach((srv, idx) => {
    // Create server UI
    const box = document.createElement("div");
    box.className = "server-box";
    box.innerHTML = `
      <h2>${srv.name}</h2>
      <div><code>${srv.url}</code></div>
      <div style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap;">
        <button class="pause important">Pause</button>
        <button class="resume">Resume</button>
        <button class="clear">Clear Log</button>
        <button class="download">Download Log</button>
        <div>Status: <span class="status">Stopped</span></div>
      </div>
      <div class="stats">
        attempts: <span class="attempts">0</span> •
        success: <span class="success">0</span> •
        fail: <span class="fail">0</span> •
        backoff: <span class="backoff">none</span>
      </div>
      <div class="logArea" aria-live="polite"></div>
    `;
    serversContainer.appendChild(box);

    // STATE
    let running = true;
    let attempts = 0, success = 0, fail = 0;
    let currentBackoff = 0;
    let logLines = [];
    let timerId = null;

    const elStatus = box.querySelector(".status");
    const elAttempts = box.querySelector(".attempts");
    const elSuccess = box.querySelector(".success");
    const elFail = box.querySelector(".fail");
    const elBackoff = box.querySelector(".backoff");
    const elLog = box.querySelector(".logArea");

    function nowISO(){ return new Date().toISOString(); }
    function addLog(msg, cls="") {
      const ts = nowISO();
      const safe = msg.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
      logLines.push({text:`[${ts}] ${safe}`, cls});
      if (logLines.length > MAX_LOG_LINES) logLines.splice(0, logLines.length - MAX_LOG_LINES);
      elLog.innerHTML = logLines.map(l => `<div class="${l.cls}">${l.text}</div>`).join('');
      elLog.scrollTop = elLog.scrollHeight;
    }
    function updateStats(){
      elAttempts.textContent = attempts;
      elSuccess.textContent = success;
      elFail.textContent = fail;
      elBackoff.textContent = currentBackoff ? (currentBackoff/1000+'s') : 'none';
    }

    async function fetchWithTimeout(url, timeout=FETCH_TIMEOUT_MS){
      const controller = new AbortController();
      const id = setTimeout(()=>controller.abort(), timeout);
      try {
        return await fetch(url, { signal: controller.signal, cache:"no-store", headers:{'X-Keep-Alive-Client': 'ping-page'} });
      } finally { clearTimeout(id); }
    }

    async function performPing() {
      attempts++; updateStats();
      const url = `${srv.url}?t=${Date.now()}`;
      addLog(`Ping -> ${url}`);
      const start = performance.now();
      try {
        const resp = await fetchWithTimeout(url);
        const elapsed = Math.round(performance.now() - start);
        addLog(`HTTP ${resp.status} ok=${resp.ok} (${elapsed}ms)`, resp.ok ? "line-ok" : "line-warn");
        if (resp.ok) {
          success++;
          currentBackoff = 0;
        } else {
          fail++;
          if ([429,503].includes(resp.status) || resp.status >= 500) {
            currentBackoff = Math.min(MAX_BACKOFF_MS, (currentBackoff || TARGET_INTERVAL_MS) * 2);
            addLog(`Backoff increased to ${currentBackoff/1000}s`, "line-warn");
          }
        }
      } catch (err) {
        fail++;
        addLog(`Fetch error: ${err}`, "line-err");
        currentBackoff = Math.min(MAX_BACKOFF_MS, (currentBackoff || TARGET_INTERVAL_MS) * 2);
        addLog(`Network error -> backoff ${currentBackoff/1000}s`, "line-warn");
      }
      updateStats();
    }

    function scheduleNext() {
      if (!running) { elStatus.textContent = "Paused"; return; }
      const base = currentBackoff || TARGET_INTERVAL_MS;
      const jitter = Math.floor(Math.random() * JITTER_MS * 2 - JITTER_MS);
      const next = Math.max(2000, base + jitter);
      elStatus.textContent = `Running (next in ${Math.round(next/1000)}s)`;
      timerId && clearTimeout(timerId);
      timerId = setTimeout(async () => {
        elStatus.textContent = "Pinging...";
        await performPing();
        scheduleNext();
      }, next);
    }

    // Button handlers
    box.querySelector(".pause").addEventListener("click", () => {
      running = false; clearTimeout(timerId);
      elStatus.textContent = "Paused";
      addLog("Paused by user", "line-warn");
    });
    box.querySelector(".resume").addEventListener("click", () => {
      if (running) return;
      running = true;
      addLog("Resumed by user", "line-warn");
      scheduleNext();
    });
    box.querySelector(".clear").addEventListener("click", () => {
      logLines = []; elLog.innerHTML = "";
      addLog("Cleared log by user", "line-warn");
    });
    box.querySelector(".download").addEventListener("click", () => {
      const text = logLines.map(l => l.text).join('\n');
      const blob = new Blob([text], {type:'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${srv.name.replace(/\s+/g,'_')}-log-${new Date().toISOString().replace(/[:.]/g,'-')}.txt`;
      a.click();
      URL.revokeObjectURL(a.href);
    });

    // INIT
    addLog("Initialized ping sequence.");
    updateStats();
    scheduleNext();
  });
})();
</script>

</body>
</html>
